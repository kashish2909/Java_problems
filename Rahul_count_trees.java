import java.util.*; public class Solution { public static void main(String args[]) { /* Since the upper bound for N is only 500 we can use a brute * force approach. We can try all possible values of i, j and * k and check that j is not equal to k and i is an ancestor of both j and k * and A[i]+A[j]+A[k]>=K. Time complexity for this approach * will be O(N^3) * The only problem now left is to check whether i * is an ancestor of j and k in O(1). For this we can * maintain a boolean table anc[][], whose (i,j)th cell will * be True if i is an ancestor of j and False otherwise. * To construct this table for each node i we can traverse * over all the nodes x lying in the path from root to i * and set anc[x][i]=True. */ Scanner sc = new Scanner(System.in); int n = sc.nextInt(); long k = sc.nextLong(); long arr[] = new long[n+1]; for(int i=1;i<=n;i++){ arr[i] = sc.nextLong(); } long dp[][]=new long[n+1][n+1]; for(int i=2;i<=n;i++){ int par = sc.nextInt(); dp[i][par] = 1; for(int j=1;j<=n;j++){ if(dp[par][j] == 1) dp[i][j] = 1; } } long count =0; for(int i=1;i<=n-2;i++){ for(int j=i+1;j<=n-1;j++){ for(int u=j+1;u<=n;u++){ if(dp[u][i]==1 && dp[j][i]==1) { if(arr[i]+arr[j]+arr[u]>=k){ count++; } } } } } System.out.println(count); } }